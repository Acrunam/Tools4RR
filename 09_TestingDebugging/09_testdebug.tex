\documentclass[12pt,t]{beamer}
\usepackage{graphicx}
\setbeameroption{hide notes}
\setbeamertemplate{note page}[plain]
\usepackage{listings}

\input{../LaTeX/header.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% end of header
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Testing and debugging}
\subtitle{Tools for Reproducible Research}
\author{\href{http://www.biostat.wisc.edu/~kbroman}{Karl Broman}}
\institute{Biostatistics \& Medical Informatics, UW{\textendash}Madison}
\date{\href{http://www.biostat.wisc.edu/~kbroman}{\tt \scriptsize \color{foreground} biostat.wisc.edu/{\textasciitilde}kbroman}
\\[-4pt]
\href{http://github.com/kbroman}{\tt \scriptsize \color{foreground} github.com/kbroman}
\\[-4pt]
\href{https://twitter.com/kwbroman}{\tt \scriptsize \color{foreground} @kwbroman}
\\[-4pt]
{\scriptsize Course web: \href{http://bit.ly/tools4rr}{\tt bit.ly/tools4rr}}
}

\begin{document}

{
\setbeamertemplate{footline}{} % no page number here
\frame{
  \titlepage

\note{We spend a lot of time debugging. We'd spend a lot less time if
  we tested our code properly.

  We want to get the right answers. We can't be sure that we've done
  so without testing our code.

  Set up a formal testing system, so that you can be
  confident in your code, and so that problems are identified and
  corrected early.

  Even with a careful testing system, you'll still spend time
  debugging. Debugging can be frustrating, but the right tools and
  skills can speed the process.
}
} }




\begin{frame}[c]{}

\centerline{"I tried it, and it worked."}

\note{This is about the limit of most programmers' testing efforts.

{\nhilit But}: Does it {\nvhilit still} work? Can you reproduce what you did?
With what variety of inputs did you try?
}

\end{frame}



\begin{frame}{Types of tests}

\bbi
\onslide<2->{\item Check inputs
\bi
\item Stop if the inputs aren't as expected
\ei
}
\item Unit tests
\bi
\item For each small function: does it give the right results in
  specific cases?
\ei
\item Integration tests
\bi
\item Check that larger multi-function tasks are working
\ei
\item Regression tests
\bi
\item Compare output to saved results, to check that things that
  worked continue working.
\ei
\ei

\note{Your first line of defense should be to include checks of the
  inputs to a function: If they don't meet your specifications, you
  should issue an error or warning.
  But that's not really {\nhilit testing}. 

  Your main effort should focus on {\nhilit unit tests}. For each
  small function (and your code {\nhilit should} be organized as a
  series of small functions), write small tests to check that the
  function gives the correct output in specific cases.

  In addition, create larger {\nhilit integration tests} to check that
  larger features are working. It's best to construct these as
  {\nhilit regression tests}: print out the output and check that it
  matches some saved version. This way, if some change you've made
  leads to a change in the results, you'll notice it automatically and
  immediately.
}
\end{frame}




\begin{frame}[c,fragile]{Check inputs}


\begin{lstlisting}
winsorize <-
function(x, q=0.006)
{
  if(!is.numeric(x)) stop("x should be numeric")

  if(!is.numeric(q)) stop("q should be numeric")
  if(length(q) > 1) {
    q <- q[1]
    warning("length(q) > 1; using q[1]")
  }
  if(q < 0 || q > 1) stop("q should be in [0,1]")

  lohi <- quantile(x, c(q, 1-q), na.rm=TRUE)
  if(diff(lohi) < 0) lohi <- rev(lohi)

  x[!is.na(x) & x < lohi[1]] <- lohi[1]
  x[!is.na(x) & x > lohi[2]] <- lohi[2]
  x
}
\end{lstlisting}


\note{
  The {\tt winsorize} function in my R/broman package hadn't included
  any checks that the inputs were okay.

  The simplest thing to do is to include some {\tt if} statements with
  calls to {\tt stop} or {\tt warning}.

  The input {\tt x} is supposed to be a numeric vector, and {\tt q} is
  supposed to be a single number between 0 and 1.
}
\end{frame}




\begin{frame}[c,fragile]{Check inputs}


\begin{lstlisting}
winsorize <-
function(x, q=0.006)
{
  stopifnot(is.numeric(x))
  stopifnot(is.numeric(q), length(q)==1, q>=0, q<=1)

  lohi <- quantile(x, c(q, 1-q), na.rm=TRUE)
  if(diff(lohi) < 0) lohi <- rev(lohi)

  x[!is.na(x) & x < lohi[1]] <- lohi[1]
  x[!is.na(x) & x > lohi[2]] <- lohi[2]
  x
}
\end{lstlisting}


\note{The {\tt stopifnot} function makes this a bit easier.
}
\end{frame}




\begin{frame}[c,fragile]{\href{http://github.com/hadley/assertthat}{\tt assertthat} package}


\begin{lstlisting}
#' import assertthat
winsorize <-
function(x, q=0.006)
{
  if(all(is.na(x)) || is.null(x)) return(x)

  assert_that(is.numeric(x))
  assert_that(is.number(q), q>=0, q<=1)

  lohi <- quantile(x, c(q, 1-q), na.rm=TRUE)
  if(diff(lohi) < 0) lohi <- rev(lohi)

  x[!is.na(x) & x < lohi[1]] <- lohi[1]
  x[!is.na(x) & x > lohi[2]] <- lohi[2]
  x
}
\end{lstlisting}


\note{Hadley Wickham's {\tt assertthat} package adds some functions that
  simplify some of this.

  How is the {\tt assertthat} package used in practice? Look at
  packages which depend on it, such as {\tt dplyr}. Download the
  source for {\tt dplyr} and try {\tt grep assert\_that dplyr/R/*} and
  you'll see a bunch of examples if its use.

  Also try {\tt grep stopifnot dplyr/R/*} and you'll see that both
  are being used.
}
\end{frame}




\begin{frame}{Tests in R packages}

\bbi
\item Examples in {\tt .Rd} files
\item Vignettes
\item {\tt tests/} directory
\ei

\note{{\tt R CMD check} is your friend.

(Sure, {\nhilit your} package is correct, but what about all of those
other R packages? If it's not on CRAN, it's {\nhilit probably crap}.)
}
\end{frame}





\begin{frame}[c]{Debugging}

\centerline{Step 1: Reproduce the problem}

\vspace{24pt}

\onslide<2->{\centerline{Step 2: Turn it into a test}}


\note{Try to create the minimal example the produces the problem. This
  helps both for refining your understanding of the problem and for
  speed in testing.

  Once you've created a minimal example that produces the problem,
  {\nhilit add that to your battery of automated tests!} The problem
  may suggest related tests to also add.
}
\end{frame}




\begin{frame}{Learn to use debugging tools}


\bbi
\item {\tt cat}
\item {\tt traceback}
\item RStudio
\item Eclipse
\item gdb
\ei

\note{
}
\end{frame}



\begin{frame}[c]{Debugging}


\centerline{Isolate the problem: where do things go bad?}

\note{``Divide and conquer.''
}
\end{frame}




\begin{frame}[c]{Debugging}


\centerline{Don't make the same mistake twice.}

\note{If you figure out some mistake you've made, search for all other
  possible instances of that mistake.
}
\end{frame}









\begin{frame}[c]{The most pernicious bugs}

\centerline{The code is right, but your thinking is wrong}

\vspace{24pt}

\onslide<2->{\centerline{You don't understand your programming language}}

\vspace{24pt}

\onslide<3->{\centerline{\hilit $\rightarrow$ Write trivial programs to
    test your understanding.}}

\note{Consider that your algorithm may be garbage.
Try an independent implementation.
}
\end{frame}




\begin{frame}[c]{Profiling}

\centerline{Don't try to optimize until the {\hilit very} end}


\note{
}
\end{frame}




\end{document}
